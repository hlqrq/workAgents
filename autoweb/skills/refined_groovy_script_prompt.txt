
You previously generated Groovy Playwright automation code for the following task.
Original User Task:
%s

Cleaned HTML snapshot of the current page/frame:
%s

Previous Groovy Code:
%s

Execution Output / Error Log:
%s

Additional User Hint For Fixing The Code:
%s

CRITICAL FIX REQUIREMENTS:
- **Optimization Goal**: Use the `web` DSL variable for robust interaction.
- **Two-Stage Process**: 
-  1. Analyze the Error and HTML. Create a "Fix Plan".
-  2. Generate the corrected Groovy code based on the plan.
- **Variable Rule**: Do NOT redeclare variables.
- **No Translation**: Do NOT translate keywords from the User Task or Hint. Use them exactly as provided.
- **Text Priority**: When the user provides a visible keyword, ALWAYS prefer locating it by that exact text over internal IDs or inferred English values.
- **Hidden Inputs**: In modern UI frameworks (like Ant Design), `input` elements are often hidden (e.g. `display:none` or `opacity:0`). 
-  - **CRITICAL**: Do NOT click/check the `input` element itself, as it will cause a timeout.
-  - **SOLUTION**: Click the visible PARENT or SIBLING element (usually a `<label>`, `<span>`, or `<div>`).
-  - Example: Instead of `web.click('input[type="checkbox"]')`, use `web.click('label:has(input[type="checkbox"])')` or just `web.click('text="Visible Label"')`.
- For table operations, PREFER per-row CSS selectors with `:nth-child()` (e.g., `".art-table-row:nth-child(i+1) td:nth-child(3)"`) instead of long `>> nth=` pipelines, which are fragile and often cause timeouts.
- For flaky elements, increase robustness with `web.withMaxRetries(5)` or `web.clickWithRetry('#selector')`. Adjust timeouts via `web.withDefaultTimeout(40000)`.

SECTION 2: DYNAMIC LISTS & TABLES (Virtual Scrolling)
**CRITICAL**: For lists that load dynamically or use virtual scrolling (e.g., `.art-table`), use the provided **High-Level APIs** instead of writing manual scroll loops.

- **Simple Extraction (Text Only)**: Use `web.extractList(containerSelector, rowSelector, limit)`.
  - Example: `List<String> rawRows = web.extractList('.art-table-body', '.art-table-row', 100)`

- **Detailed Extraction (Structured Data)**: Use `web.extractTableData(containerSelector, rowSelector, limit, columnsMap)`.
  - **CRITICAL**: Do NOT iterate over rows using `nth-child` indices after extraction. Virtual lists do not support random access by index after scrolling.
  - Example:
    ```groovy
    Map<String, String> columns = [
        "OrderNo": "td:nth-child(2)", 
        "Status": ".status-label"
    ]
    List<Map<String, String>> data = web.extractTableData('.art-table-body', '.art-table-row', 50, columns)
    ```
  - If scrolling yields few rows repeatedly, try the nearest scrollable ancestor of rowSelector as container and retry.
  - Do NOT use `:visible` or count visible rows to infer full page size on virtual lists.

- **Finding & Interacting with Specific Item**: Use `web.locateItem(containerSelector, rowSelector, textToFind)`.
  - It scrolls until it finds the item and makes it visible.
  - Example:
    ```groovy
    if (web.locateItem('.art-table-body', '.art-table-row', 'Order_123')) {
        web.log("Found order, clicking detail...")
        // Click button in the now-visible row
        web.clickButton('Detail') 
    }
    ```

- **Selecting First Item**:
  - Since `extractList` automatically resets to top, you can simply select the first visible row afterwards.
  - Example:
    ```groovy
    web.extractList(...) 
    // Now at top
    web.log("Selecting first item...")
    web.click('.art-table-row:nth-child(1) input[type="checkbox"]')
    ```

API REFERENCE (DSL - variable 'web'):
  - `click(selector)`, `clickButton(text)`: Click element.
  - `clickWithRetry(selector)`: Click with retries based on `withMaxRetries`.
  - `type(selector, text)`: Type text.
  - `withDefaultTimeout(ms)`: Set default wait timeout.
  - `withMaxRetries(n)`: Set retry count for actions.
  - `check(selector)`, `uncheck(selector)`: For checkboxes/radios.
  - `isChecked(selector)`: Returns boolean.
  - `selectOption(selector, valueOrLabel)`: For standard `<select>`.
  - `getText(selector)`: Get inner text.
  - `getAllText(selector)`: Get list of texts for all matching elements.
  - `count(selector)`: Get number of matching elements.
  - `waitFor(selector)`: Wait for element to appear (default 30s).
  - `wait(millis)`: Pause execution.
  - `hover(selector)`: Hover mouse over element.
  - `scrollIntoView(selector)`: Scroll to element.
  - `mouseWheel(selector, deltaY)`: Hover over selector and scroll wheel (robust for virtual lists).
  - `press(selector, key)`: Press keyboard key (e.g. 'Enter') on element.
  - `scrollToBottom()`, `scrollToBottom(selector)`: Scroll window or element to bottom.
  - `scrollToTop(selector)`: Scroll element to top (CRITICAL for virtual lists before extraction).
  - `scrollBy(selector, amount)`: Scroll element by amount pixels (e.g. 500).
  - `log(msg)`: Log message.
  - `findRowIndex(rowSelector, cellText)`: Find row index containing text.
  - `extractList(containerSelector, rowSelector, limit)`: **POWERFUL**. Scrolls, extracts, deduplicates, and resets to top. Returns `List<String>`.
  - `extractTableData(containerSelector, rowSelector, limit, columnsMap)`: **POWERFUL**. Returns `List<Map<String, String>>`.
  - `locateItem(containerSelector, rowSelector, textToFind)`: **POWERFUL**. Scrolls until item is found and visible. Returns `boolean`.
- PREFER these DSL methods over raw Playwright calls.

Output ONLY the final Groovy code (including the Plan comments).

Example Format:
```groovy
// FIX PLAN:
// 1. Selector for 'Login' failed. Use 'button[name="login"]' instead.
// 2. Add wait before clicking.

// CODE:
web.log("Retrying login...")
web.waitFor('button[name="login"]')
web.click('button[name="login"]')
```
